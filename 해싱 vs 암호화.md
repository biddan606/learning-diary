# 해싱(Hashing) vs 암호화(Encryption)

해싱(Hashing)과 암호화(Encryption)에 대한 개념이 헷갈려 정리해봅니다.   
해싱과 암호화의 차이를 분석하기 전에, 비슷한 개념인 인코딩(Encoding), 난독화(Obfuscation)을 추가해 비교하고 해싱과 암호화에 대해 깊이 비교해보겠습니다.   

## 인코딩(Encoidng) vs 암호화(Encryption) vs 해싱(Hashing) vs  vs 난독화(Obfuscation)

4가지는 어떤 방식으로 만드는지는 중요하지 않습니다.   
각 방식마다의 목적이 중요하고 목적을 충족하기 위한 조건들을 보장되어야 합니다.   

**인코딩(Encoidng)**: 데이터의 형식을 변환하는 것이 목적입니다. 변환하는 방식이 비밀스럽지 않아도 되고, 인코딩값과 디코딩값을 추적하기 쉬워도 됩니다. 단순히 데이터 형태를 맞추기 위해 변환하는 목적입니다.   

**암호화(Encryption)**: 데이터를 비밀로 유지하기 위한 사용하는 것이 목적입니다. 암호문(Ciphertext)을 통해 평문(Plaintext)을 추적할 수 있게 하면 안됩니다. 그래서 암호문->평문으로 변환하는 키도 비밀로 유지해야 합니다.   

**해싱(Hashing)**: 해시값이 변조되지 않았음을 증명하는 것이 주목적입니다. 그래서 항상 A는 B인 해시값을 가져야합니다.(무결성)   
또한, 단방향이어야 합니다. 이는 변조되지 않았음을 명확히 하기 위해서입니다. 만약 양방향이라면, 같은 해시값->위조된 데이터를 만들 수 있습니다.(해시값은 고유성을 보장하지 않으므로, 해시충돌)

**난독화(Obfuscation)**: 단순히 값을 읽기 힘들게 만드는 것이다. 예를 들어) `hello world` -> `olleh dlrow` 처럼 읽기 힘든 형태로 만드는 것이다. 하지만 프로덕션 환경에서는 난독화 하는 이유가 (읽기 힘들게 하기 + 보안)의 이유일 수도 있으므로 암호화 기법을 사용하기도 합니다.

## 암호화(Encryption) 

암호화는 민감한 데이터에 대한 접근을 보호하기 위해 사용됩니다.   
암호화 방식으로는 대칭키, 비대칭키가 있습니다.   

### 대칭키 장단점

ssh처럼 특정 상대와 통신할 때, 사용됩니다. 암호화, 복호화 때 모두 동일한 비밀키(secret key)를 사용합니다.

**장점**
- 암호화, 복호화가 빠르다.

**단점**
- 키 분배 문제, 특정 상대방한테 안전하게 키를 전달해야 하는 제약이 있습니다.
- 상대가 증가할수록 키도 많아집니다.
- 양쪽 사용자가 모두 키 보안에 신경써야 합니다.

### 비대칭키 장단점

https처럼 불특정 다수와 통신할 때 사용합니다. 불특정 다수에게 공개키를 오픈하여 클라이언트가 공개키로 암호화를 하고, 서버는 개인키로 복호화합니다.

**장점**
- 키 분배 문제가 없습니다.
- 서버만 보안을 유지하면 됩니다.
- 유저가 늘어도 공개키, 개인키는 1개만 있어도 됩니다.

**단점**
- 복호화하는 과정이 오래걸립니다. 비밀키를 무차별 대입하여 비밀키를 특정할 수 있어, 복호화 과정이 있는 비밀키를 사용합니다.(아직 암호화에 있어 완벽한 해결책은 없음)

## 무결성 해싱(Hashing)

해싱은 무결성을 검증하기 위해 사용됩니다. 평문->해시값으로 변환하여 데이터가 변조되지 않았음을 보장합니다.   

### 안전하게 보장하기 위한 조건

**예제**

1. A가 B에게 1_000달러를 빌려주었고, B는 A가 1000달러를 은행에서 찾아갈 수 있게 차용증을 기반으로 해시값을 만들어 은행에 저장해두었습니다.(A의 이름과 1_000달러)   

2. A는 차용증을 가지고 은행에 가면 1_000달러를 받을 수 있습니다.

**위조 시나리오**

- 해시값을 변환해보니, (A의 이름, 1만 달러)와 약간의 차용증 내용 수정으로도 만들 수 있다는 걸 알게 되었습니다. 이를 이용해 A는 차용증을 위조하여 더 많은 금액을 가져가게 되었습니다.

- 역해싱 불가능한 경우, A가 (A의 이름, 1만 달러)로 내용을 수정하고 차용증 내용을 조금씩 수정하며 수천만개의 해시를 만들었습니다. 그랬더니 은행에 저장해둔 해시값과 일치하는 위조 문서를 만들 수 있었습니다.

**안전 조건**

- 해시 충돌이 적게 나야합니다. 발생할 수 있는 문제를 미연에 방지합니다.(아예 발생하지 않게 하는 건 불가능)

- 역해싱이 불가능해야 합니다.(이는 보안에서도 큰 문제가 됨)

**이미 해시값이 정해졌다면**: `salting`이라는 기법을 사용할 수 있습니다. 2개의 해시값을 발급하는 겁니다. 차용증 해시값, 차용증의 특정 위치에 문자를 넣은 뒤 만든 해시값으로 이중 검증을 합니다. 이럴 경우, 위조하기가 쉽지 않습니다.

### 또다른 예

해시는 비밀번호에서도 많이 사용합니다.   
옛날에는 `MD5` 해시 함수를 많이 사용하였는데, 문제가 있었습니다.

#### MD5의 문제

`MD5`는 역해싱이 불가능하지만, 해시값의 길이가 짧아 문제가 발생합니다.   

**해시 충돌**: 해시값이 짧아, 해시 충돌이 많이 일어납니다. 다른 비밀번호를 입력하더라도 로그인이 될 수 있습니다.   

**레인보우 테이블**: `MD5`는 오래된 역사와 짧은 해시값, 빠른 계산 속도로 인해 방대한 레인보우 테이블이 구축되어 왔습니다. 이로 인해 레인보우테이블과 해시값으로 원본 데이터를 쉽게 예측할 수 있습니다.   

이를 해결하기 위해 `MD5`를 사용하는 서버에서는 원본데이터 + `salting`하여 해시값을 만들기도 합니다. 이렇게 되면 레인보우 테이블과 매칭되는 값이 없을 확률이 높아집니다.   

하지만 그럼에도 위험성이 있으므로 되도록이면 `MD5`를 피하고, `SHA-256`과 같은 함수를 사용하는 것이 좋습니다.(현재까지 해시충돌이 나지 않았다고 함)

## 참조

- [Difference Between Encryption vs Encoding vs Hashing vs Obfuscation Explained - Learn with Whiteboard Youtube](https://www.youtube.com/watch?v=z7FTY7bRy_k)

- [Hashing vs Encryption Differences - Programming w/ Professor Sluiter Youtube](https://www.youtube.com/watch?v=GI790E1JMgw)