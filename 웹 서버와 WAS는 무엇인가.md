# 웹 서버와 WAS는 무엇인가?

웹 서버는 클라이언트(웹 브라우저)의 요청을 받아 정적 컨텐츠(HTML, 파일, 이미지 등)를 제공하는 서버다.   
WAS(Web Application Server)는 동적 컨텐츠를 제공하기 위해 사용되며, 사용자의 요청에 따라 서버에서 프로그램을 실행한 후 그 결과를 사용자에게 전송한다.

## 대표적인 웹 서버와 WAS

**웹서버**: Apache HTTP Server, Nginx   
**WAS**: Apache Tomcat, Jeus

## 웹 서버와 WAS가 분리되어야 하는 이유
웹 서버는 정적 컨텐츠, WAS는 동적 컨텐츠를 담고 있습니다. 한데, 웹 서버는 정적 컨텐츠만을 다루므로 부하가 크지 않을 거 같고 이 역할을 WAS가 해도 충분하지 않을까 생각한다. 왜 웹 서버와 WAS가 분리되어야 하는 걸까?   

처음부터 이야기하자면, 초기에는 웹 서버와 WAS를 분리할 필요가 없었을 거 같다. (PHP의 경우 웹 서버만을 이용해서 동적인 요청까지 처리 가능)   
하지만 지속적인 발전과 트래픽이 증가하면서 필요해지지 않았을까 싶다. 트래픽량이 증가하고 고가용성이 중요해지면서 WAS가 여러 대가 도입되었다. 이러면 이 서버들을 묶어 라우팅해주는 역할이 필요해진다. 이 역할을 웹 서버가 담당한다.   
현대 구조에서는 웹 서버가 WAS 라우팅과 정적 컨텐츠 역할을 하고(에러 페이지 출력 등) 동적 컨텐츠의 역할을 WAS 담당한다.   

## 웹 서버 대신 WAS가 라우팅해주면 되지 않을까?

웹 서버 대신 WAS가 라우팅을 해줄 수 있을 것 같다. 하지만 내가 서버를 구축해보면서 WAS를 업데이트하거나 다시 띄우는데는 시간이 오래 걸린다. 대신 웹 서버를 띄우는 데는 굉장히 짧은 시간이 걸린다. (사람에게 체감되지 않을 정도로 짧은 시간, 많은 역할을 담당하는 것이 아니라 빠르게 올라가는 거 같다.)   
서버를 많이 띄워 병렬적으로 늘려 고가용성을 보장하려고 해도 한 군데에서는 SPOF(Single Point Of Failure, 단일 장애점)이 존재한다. 이 역할을 변경할 가능성이 적고, 빠르게 업데이트 되는 웹 서버가 담당해야 최소화 되지 않을까? 하는 생각이다.

## SpringBoot WAS는 어떻게 동작할까?
  
![alt text](image/WAS_Servlet.png)
위 그림은 웹 서버, WAS, 서블릿이 어떻게 상호작용하는지를 보여주는 그림이다. 그림과 `Springboot` 에서의 동작 방식이 약간 다르지만 서블릿의 동작 방식을 이해하면 `Spring Boot WAS` 방식을 이해하기 편할 것 같아 추가하였다.

1. 클라이언트 요청: 클라이언트에서 HTTP 요청이 발생한다.
2. 요청이 웹 서버에 도달하면 웹 서버는 요청을 처리할 수 있는 WAS로 요청을 보낸다.
3. WAS 내부의 웹 컨테이너는 요청을 처리하기 위해 별도의 스레드를 할당한다.
4. 각 스레드는 요청에 맞는 서블릿 인스턴스의 `service()` 를 호출하여 요청을 처리한다.
5. 상호작용이 필요한 경우 데이터 베이스를 이용하여 데이터 조회 또는 업데이트를 한다.
6. 처리가 완료되면, 웹 컨테이너는 결과를 웹 서버를 통해 클라이언트에게 반환한다.

### 그렇다면 Spring Boot는?

1. 클라이언트로부터 웹 서버가 요청을 받습니다.
2. 웹서버는 정적 리소스의 요청이 아닌 경우 해당 요청을 `SpringBoot`로 전달합니다.
3. `DispatcherServlet`이 해당 요청을 받습니다.(`SpringMVC` 는 모든 요청을 중앙에서 처리하는 프론트 컨트롤러인 `DispatcherServlet` 가 받는다, `DispatcherServlet` 는 스프링 부트 애플리케이션의 핵심적인 진입점)
4. `DispatcherServlet` 는 요청 URL을 분석하여 해당 요청을 처리할 컨트롤러를 찾습니다.(이 과정에서 핸들러 매핑이 일어남)
5. 매핑된 컨트롤러의 메소드가 실행된다. 이 메소드는 로직을 실행하고 결과 데이터를 모델 객체에 저장한다.
6. 컨트롤러 처리를 마치고, `View Resolver` 가 실제 뷰를 찾아내어 모델 데이터를 뷰에 전달한다.
7. 뷰는 모델을 사용하여 응답으로 렌더링한다.
8. 생성된 응답은 `DispatcherServlet` 을 통해 클라이언트에게 반환된다.

### @RestController의 경우

위에 설명한 로직은 뷰를 이용해 html을 렌더링하여 http로 보낸다. 하지만 내가 주로 하는 작업은 json이다. `@RestController` 를 이용해 json으로 변환하는 과정을 추가하여 설명해보겠습니다.   
요청을 받는 과정까지는 똑같지만 응답을 보내는 방식이 다르다. 응답을 보낼 때 `@Controller` 는 요청으로 받은 모델에 담아 보낸다. `@RestController` 는 json으로 보내기 때문에 모델에 담을 필요가 없다. 로직으로 나온 결과를 그대로 보낸다. 그렇게 되면 `HttpMessageConverter` 인터페이스를 구현한 클래스인 `MappingJackson2HttpMessageConverter` 이 `POJO(Plain Old Java Object)` 를 HTTP 응답 본문으로 변환한다. 이후 `DispatcherServlet` 가 변환된 HTTP 응답을 클라이언트에게 보낸다.
