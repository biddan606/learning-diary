# 블로킹I/O와 논블로킹I/O, 동기와 비동기

블로킹I/O와 논블로킹I/O, 동기와 비동기 이 두 가지 개념이 헷갈립니다.  
먼저 블로킹I/O와 논블로킹I/O을 알아보고, 동기와 비동기를 알아보겠습니다. 이후 2개의 개념을 활용하는 작업을 알아보며 명확한 차이와 각각의 특징을 더욱 자세히 느껴보겠습니다.

# 블로킹I/O와 논블로킹I/O

## 블로킹I/O

I/O의 작업을 요청한 프로세스/스레드가 요청이 완료될 때까지 기다리는 것을 말합니다.

![alt text](<image/블로킹IO 설명.png>)

위 그림처럼 스레드가 블로킹IO 작업을 할 때는 요청이 완료될 때까지 기다립니다. 이럴 경우 블락 상태에서 오래 머물 수 있습니다.  
오래 머물러 비효율적이지만, 스레드가 다음 동작을 수행할 때 IO 작업으로부터 받는 데이터가 반드시 필요하다면 어쩔 수 없습니다. 블락 상태동안 CPU와 메모리 자원을 점유하고 있다면 정말 비효율적이 됩니다. 그래서 현대 컴퓨터는 멀티스레드 방식으로 이를 극복합니다.

## 논블로킹I/O

프로세스/스레드를 블락시키지 않고 요청에 대한 현재 상태를 바로 반환합니다. 예를 들어, 블로킹I/O에서는 `read` 시에 `read buffer` 가 비어있다면 블락 상태가 됩니다. 하지만 논블로킹I/O에서는 -1이나 특정 값을 즉시 리턴해줍니다.  
논블로킹I/O에서는 반환 받을 데이터를 사용하지 않더라도 다른 작업을 먼저 수행할 수 있을 떄 사용합니다.

![alt text](<image/논블로킹IO 설명.png>)

위 그림처럼 스레드는 IO작업에 대한 응답을 즉시 받고 다른 작업을 먼저 수행합니다. 다른 작업이 끝나거나 응답값이 필요한 시점에 응답값 반환을 재요청해서 처리합니다. 블로킹I/O처럼 블락 상태가 유지되지 않아 효율적인 것처럼 보이지만 항상 그런 것은 아닙니다. 재요청 처리를 자주하여 오히려 비효율적이 될 수도 있고, 응답값을 즉시 리턴받을 수 없어 빠른 처리가 불가능할 수도 있습니다.

## 블로킹을 효율적으로 처리하는 방법, I/O 멀티플렉싱

I/O 멀티플렉싱에 대해 알아보기 전에 I/O 멀티플렉싱이 왜 생겨났는지부터 알아보겠습니다.  
블로킹과 논블로킹만을 단순히 사용한다면 굉장히 비효율적일 수 있습니다. 많은 스레드들이 존재하고 이 스레드들이 모두 요청을 받는다고 하면 블로킹과 논블로킹은 어떻게 처리할까요? 논블로킹부터 알아보겠습니다.

### 여러 쓰레드와 논블로킹

논블로킹일 때는 여러 스레드들에 요청이 들어왔는지를 주기적으로 전부 검사해주어야 합니다.  
아래 그림에서는 8개의 소켓을 통해 요청을 받을 수 있습니다. 이 경우 주기적으로 8개의 소켓들을 모두 검사합니다.

![alt text](<image/IO 멀티플렉싱 논블로킹 시점.png>)

### 여러 쓰레드와 블로킹

그럼 블로킹으로 하면 효율적으로 개선할 수 있을까요? 아닙니다. 블로킹의 경우 1개의 소켓이 동기화 되기 전까지 다른 소켓들을 체크하지 않습니다. 더 큰 비효율성을 야기합니다.

![alt text](<image/IO 멀티플렉싱 블로킹 시점.png>)

### I/O 멀티플렉싱은 무엇이고, 어떻게 해결하는가?

I/O 멀티플렉싱은 관심 있는 I/O 작업들을 묶어 동시에 모니터링하고, 그 중 완료된 I/O 작업들을 한번에 올려줍니다.

![alt text](<image/IO 멀티플렉싱 로직.png>)

다이어그램을 통해 동작 방식을 보면 보다 쉽게 이해할 수 있습니다.

1. 스레드는 소켓에 요청이 들어왔는지 알아보는 것이 아니라 I/O 멀티플렉싱에 read 요청을 합니다.
2. 블로킹I/O일 경우 블락 상태가 되고, 논블로킹I/O일 경우 다른 작업을 수행합니다.(그림은 블로킹 시점)
3. I/O 멀티플렉싱이 완료된 작업을 감지하면 알림을 날려줍니다.
4. 스레드는 알림 작업을 통해 받은 소켓들에게 `read` 수행합니다.(해당 소켓들은 `read`를 바로 수행할 수 있는 상태)

# 동기와 비동기

블로킹과 논블로킹은 IO 작업을 요청한 후, 응답을 대기하여 즉시 작업을 수행할지, 응답을 미루어 나중에 작업을 수행할지로 나뉘는 것을 알 수 있었습니다.  
그렇다면 동기와 비동기는 어떤 특징이 있을까요?

## 동기(synchronous)

동기는 호출한 쪽에서 작업의 완료 여부를 계속 확인하고, 완료되면 직접 결과를 가져와 처리합니다.

![alt text](<image/sychronous 설명 그림.png>)

위 그림은 동기화로 진행되는 커뮤니케이션을 보여주고 있습니다. A는 B로 요청을 보내고 대기/다른 작업을 수행할 수 있고 B에서 보낸 응답을 처리합니다. B도 A과 같은 방식으로 C와 커뮤니케이션을 합니다.

## 비동기(asynchronous)

비동기는 호출된 쪽에서 작업이 완료되면 콜백, 이벤트, Promise 등을 통해 결과를 전달합니다.
호출한 쪽은 작업 완료를 기다리지 않고 다른 작업을 수행할 수 있습니다.

![alt text](<image/asychronous 설명 그림.png>)

위 그림은 비동기로 진행되는 커뮤니케이션을 보여주고 있습니다.
A는 메시지 큐에 이벤트를 발행(produce)한 후, 결과를 기다리지 않고 자신의 작업을 계속 수행합니다.
B는 메시지 큐에서 이벤트를 소비(consume)하여 처리하고, 필요시 다른 메시지 큐에 새로운 이벤트를 발행합니다.
A는 B의 처리 결과를 직접 받지 않으며, 각자 독립적으로 동작합니다.
이처럼 요청자가 응답을 기다리지 않고, 각 컴포넌트가 독립적으로 작동하는 것을 비동기라고 합니다.

## 결론: 블로킹/논블로킹과 동기/비동기의 관계

### 두 개념의 핵심 차이

- **블로킹/논블로킹**: **제어권** 관점 - "호출한 함수가 바로 리턴하는가?"
- **동기/비동기**: **결과 처리** 관점 - "작업 완료를 누가 신경쓰는가?"

### 4가지 조합

**1. 동기 + 블로킹 (Sync-Blocking)**

- **동작**: 작업 완료까지 대기 → 직접 결과 확인
- **예시**: `read()`, `write()` 시스템 콜
- **사용처**: 간단한 스크립트, 순차적 데이터 처리
- **선택 이유**:
  - 코드가 위에서 아래로 순서대로 실행되어 이해하기 쉬움
  - 결과가 나올 때까지 확실하게 기다려야 할 때
  - 복잡한 동시성 제어가 필요 없는 단순한 작업

**2. 동기 + 논블로킹 (Sync-NonBlocking)**

- **동작**: 즉시 리턴 → 주기적으로 완료 확인(폴링)
- **예시**: `select()`, `poll()` 시스템 콜
- **사용처**: 여러 연결을 동시에 관리하는 서버, 실시간 모니터링
- **선택 이유**:
  - 하나의 스레드로 여러 작업을 돌아가며 확인 가능
  - 블로킹처럼 하나만 기다리지 않아 효율적
  - 각 작업마다 "최대 얼마나 기다릴지" 제어 가능

**3. 비동기 + 논블로킹 (Async-NonBlocking)**

- **동작**: 즉시 리턴 → 완료 시 콜백/이벤트로 통지
- **예시**: Node.js, epoll, JavaScript Promise
- **사용처**: 고성능 서버, 대량 동시 연결 처리
- **선택 이유**:
  - CPU와 I/O 자원을 최대한 효율적으로 활용
  - 수천~수만 개의 동시 연결 처리 가능 (C10K 문제 해결)
  - 응답성이 중요한 실시간 시스템에 적합

**4. 비동기 + 블로킹 (Async-Blocking)**

- **동작**: 비동기 작업 시작 → 결과를 동기적으로 대기
- **예시**: Future.get() (Java), await (JavaScript)
- **사용처**: 비동기 작업의 동기적 처리, 병렬 작업 후 일괄 대기
- **선택 이유**:
  - 비동기 코드를 동기 스타일로 작성 가능 (가독성 향상)
  - 여러 작업을 병렬로 시작한 후 모든 결과를 한 번에 수집
  - 복잡한 콜백 체인을 단순한 코드로 변환 가능(콜백 지옥 해결)

### 핵심 요약

블로킹/논블로킹은 "**기다림의 방식**"을, 동기/비동기는 "**완료 처리의 주체**"를 결정합니다.

- **성능 최적화**: 비동기 + 논블로킹 (대량 요청 처리)
- **구현 단순성**: 동기 + 블로킹 (직관적 코드)
- **절충안**: 동기 + 논블로킹 (I/O 멀티플렉싱), 비동기 + 블로킹 (비동기의 동기적 처리)

각 조합은 장단점이 있으므로, 시스템 요구사항에 맞는 적절한 선택이 중요합니다.

## 참조

[block I/O vs non-block I/O - 쉬운 코드](https://www.youtube.com/watch?v=mb-QHxVfmcs&list=PLcXyemr8ZeoQOtSUjwaer0VMJSMfa-9G-&index=15)

[비동기 프로그래밍 - 쉬운 코드](https://www.youtube.com/watch?v=EJNBLD3X2yg)

[Blocking I/O와 Non-blocking I/O - 널널한 개발자](https://www.youtube.com/watch?v=XNGfl3sfErc&list=PLXvgR_grOs1DiPUK8VSR8SXqKws4O3qkz&index=24)

[Non-blocking I/O와 Multi-threading은 바늘과 실이다. - 널널한 개발자](https://www.youtube.com/watch?v=H01FkDtllwc&list=PLXvgR_grOs1DiPUK8VSR8SXqKws4O3qkz&index=26)

[백엔드 개발자들이 알아야할 동시성 2 — 블로킹과 논블로킹, 동기와 비동기 - 블로그 글](https://choi-geonu.medium.com/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EB%8F%99%EC%8B%9C%EC%84%B1-2-%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-e11b3d01fdf8)

// todo: 읽고 수정
