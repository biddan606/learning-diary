# 블로킹I/O와 논블로킹I/O, 동기와 비동기

블로킹I/O와 논블로킹I/O, 동기와 비동기 이 두 가지 개념이 헷갈립니다.   
먼저 블로킹I/O와 논블로킹I/O을 알아보고, 동기와 비동기를 알아보겠습니다. 이후 2개의 개념을 활용하는 작업을 알아보며 명확한 차이와 각각의 특징을 더욱 자세히 느껴보겠습니다.

# 블로킹I/O와 논블로킹I/O

## 블로킹I/O

I/O의 작업을 요청한 프로세스/스레드가 요청이 완료될 때까지 기다리는 것을 말합니다.

![alt text](<image/블로킹IO 설명.png>)

위 그림처럼 스레드가 블로킹IO 작업을 할 때는 요청이 완료될 때까지 기다립니다. 이럴 경우 블락 상태에서 오래 머물 수 있습니다.   
오래 머물러 비효율적처럼 보이지만, 스레드가 다음 동작을 수행할 때 IO 작업으로부터 받는 데이터가 반드시 필요하다면 어쩔 수 없습니다. 블락 상태동안 CPU와 메모리 자원을 점유하고 있다면 정말 비효율적이 됩니다. 그래서 현대 컴퓨터는 멀티스레드 방식으로 이를 극복합니다.

## 논블로킹I/O

프로세스/스레드를 블락시키지 않고 요청에 대한 현재 상태를 바로 반환합니다. 예를 들어, 블로킹I/O에서는 `read` 시에 `read buffer` 가 비어있다면 블락 상태가 됩니다. 하지만 논블로킹I/O에서는 -1이나 특정 값을 즉시 리턴해줍니다.   
논블로킹I/O에서는 반환 받을 데이터를 사용하지 않더라도 다른 작업을 먼저 수행할 수 있을 떄 사용합니다. 

![alt text](<image/논블로킹IO 설명.png>)

위 그림처럼 스레드는 IO작업에 대한 응답을 즉시 받고 다른 작업을 먼저 수행합니다. 다른 작업이 끝나거나 응답값이 필요한 시점에 응답값 반환을 재요청해서 처리합니다. 블로킹I/O처럼 블락 상태가 유지되지 않아 효율적인 것처럼 보이지만 항상 그런 것은 아닙니다. 재요청 처리를 자주하여 오히려 비효율적이 될 수도 있고, 응답값을 즉시 리턴받을 수 없어 빠른 처리가 불가능할 수도 있습니다.

## 블로킹을 효율적으로 처리하는 방법, I/O 멀티플렉싱

I/O 멀티플렉싱에 대해 알아보기 전에 I/O 멀티플렉싱이 왜 생겨났는지부터 알아보겠습니다.   
블로킹과 논블로킹만을 단순히 사용한다면 굉장히 비효율적일 수 있습니다. 많은 스레드들이 존재하고 이 스레드들이 모두 요청을 받는다고 하면 블로킹과 논블로킹은 어떻게 처리할까요? 논블로킹부터 알아보겠습니다.

### 여러 쓰레드와 논블로킹

논블로킹일 때는 여러 스레드들에 요청이 들어왔는지를 주기적으로 전부 검사해주어야 합니다.   
아래 그림에서는 8개의 소켓을 통해 요청을 받을 수 있습니다. 이 경우 주기적으로 8개의 소켓들을 모두 검사합니다.

![alt text](<image/IO 멀티플렉싱 논블로킹 시점.png>)

### 여러 쓰레드와 블로킹

그럼 블로킹으로 하면 효율적으로 개선할 수 있을까요? 아닙니다. 블로킹의 경우 1개의 소켓이 동기화 되기 전까지 다른 소켓들을 체크하지 않습니다. 더 큰 비효율성을 야기할 수 있습니다.

![alt text](<image/IO 멀티플렉싱 블로킹 시점.png>)

### I/O 멀티플렉싱는 무엇이고, 어떻게 해결하는가?

I/O 멀티플렉싱은 관심 있는 I/O 작업들을 묶어 동시에 모니터링하고, 그 중 완료된 I/O 작업들을 한번에 올려줍니다.

![alt text](<image/IO 멀티플렉싱 로직.png>)

다이어그램을 통해 동작 방식을 보면 보다 쉽게 이해할 수 있습니다.

1. 스레드는 소켓에 요청이 들어왔는지 알아보는 것이 아니라 I/O 멀티플렉싱에 read 요청을 합니다.
2. 블로킹I/O일 경우 블락 상태가 되고, 논블로킹I/O일 경우 다른 작업을 수행합니다.(그림은 블로킹 시점)
3. I/O 멀티플렉싱이 완료된 작업을 감지하면 알림을 날려줍니다.
4. 스레드는 알림 작업을 통해 받은 소켓들에게 `read` 수행합니다.(해당 소켓들은 `read`를 바로 수행할 수 있는 상태)

# 동기와 비동기

블로킹과 논블로킹은 IO 작업을 요청한 후, 응답을 대기하여 즉시 작업을 수행할지, 응답을 미루어 나중에 작업을 수행할지로 나뉘는 것을 알 수 있었습니다.   
그렇다면 동기와 비동기는 어떤 특징이 있을까요?

## 동기(sychronous)

동기는 요청을 보낸 프로세스/스레드가 응답을 받아 처리합니다.

![alt text](<image/sychronous 설명 그림.png>)

위 그림은 동기화로 진행되는 커뮤니케이션을 보여주고 있습니다. A는 B로 요청을 보내고 대기/다른 작업을 수행할 수 있고 B에서 보낸 응답을 처리합니다. B도 A과 같은 방식으로 C와 커뮤니케이션을 합니다.

## 비동기(asychronous)

비동기는 요청을 보낸 프로세스/스레드가 응답을 처리하는 대신 다른 프로세스/스레드로 위임합니다.

![alt text](<image/asychronous 설명 그림.png>)

위 그림은 비동기화로 진행되는 커뮤니케이션을 보여주고 있습니다. A는 요청을 보내고 난 뒤 응답을 받지 않습니다. 대신 B가 응답을 처리합니다. B 또한 C에게 응답을 위임합니다. 이처럼 요청에 대한 응답을 처리를 위임하는 것을 비동기라고 할 수 있습니다.   


## 참조

[block I/O vs non-block I/O - 쉬운 코드](https://www.youtube.com/watch?v=mb-QHxVfmcs&list=PLcXyemr8ZeoQOtSUjwaer0VMJSMfa-9G-&index=15)   

[비동기 프로그래밍 - 쉬운 코드](https://www.youtube.com/watch?v=EJNBLD3X2yg)   

[Blocking I/O와 Non-blocking I/O - 널널한 개발자](https://www.youtube.com/watch?v=XNGfl3sfErc&list=PLXvgR_grOs1DiPUK8VSR8SXqKws4O3qkz&index=24)   

[Non-blocking I/O와 Multi-threading은 바늘과 실이다. - 널널한 개발자](https://www.youtube.com/watch?v=H01FkDtllwc&list=PLXvgR_grOs1DiPUK8VSR8SXqKws4O3qkz&index=26)   

[백엔드 개발자들이 알아야할 동시성 2 — 블로킹과 논블로킹, 동기와 비동기 - 블로그 글](https://choi-geonu.medium.com/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EB%8F%99%EC%8B%9C%EC%84%B1-2-%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-e11b3d01fdf8)
