# Spring에서 Interceptor와 Servlet Filter

`Interceptor`와 `Servlet Filter`는 요청 처리 과정 앞뒤로 개입하는 기능입니다.   

## 필터

필터는 Spring 프레임워크가 아닌 웹서버의 일부입니다. 서블릿 자체에 도달하지 못하도록 조작하거나 차단할 수 있습니다.

### 사용 예시

- 인코딩 필터: 요청과 응답에 문자 인코딩을 지정하여 문자 인코딩 문제를 방지합니다.(예를 들어, `CharacterEncodingFilter` 를 사용하여 모든 요청과 응답에 UTF-8 인코딩을 적용할 수 있음)
- CORS 필터

### 장단점

#### 장점

- Spring MVC에 국한되지 않고, 다른 자바 웹 프레임워크에서도 사용될 수 있습니다.
- 애플리케이션에 도달하기 전 사전 처리를 수행할 수 있습니다.

#### 단점

- Spring 컨텍스트 접근 불가: 스프링 컨텍스트 밖에서 동작하므로, 스프링 빈에 직접 접근할 수 없습니다.(특정 컨트롤러나 메서드에 대한 세밀한 제어가 필요한 경우, 필터만으로는 이를 구현하기 어렵습니다)

## 인터셉터

Spring MVC의 일부입니다. `DispatcherServlet`과 `Controller` 사이에 위치합니다. 요청이 컨트롤러에 도달하기 전, 뷰가 렌더링되기 전과 후에 가로챌 수 있습니다.   

### 처리 과정

1. Handler Mapping: 요청 URL을 처리할 컨트롤러 메서드와 매핑합니다.
2. Interceptor(preHandle()): 요청을 가로채 필요한 사전 처리를 합니다.
3. ArgumentResolver: 핸들러 메서드의 인자를 결정합니다.
4. Controller: 매핑된 컨트롤러의 메서드가 실행되어 요청을 처리하고, 처리 결과를 ModelAndView 객체에 담아 DispatcherServlet으로 반환합니다.
5. Interceptor(postHandle()): 뷰를 렌더링하기 전에 실행됩니다.
6. ViewResolver: DispatcherServlet은 컨트롤러부터 받은 ModelAndView 객체를 사용하여 응답을 생성할 뷰를 결정합니다. 적절한 뷰를 찾아 렌더링하고, 최종적으로 클라이언트에게 응답을 보냅니다.
7. Interceptor(afterCompletion()): 요청 처리 및 뷰 렌더링 완료 후 콜백됩니다.

### 사용 예시

- 로깅 인터셉터: 요청 URL, 처리 시간, 상태 코드등을 로깅
- 권한 인터셉터: 특정 URL 패턴에서 사용자의 권한을 확인하여 접근을 제한할 수 있습니다.

### 장단점

#### 장점

- 스프링 통합: 인터셉터는 스프링 MVC의 일부로, 스프링 컨텍스트와 완벽하게 통합됩니다.(스프링의 다양한 기능 활용 가능)
- 세밀한 제어
- 다양한 콜백 메서드: 요청 처리 전,후 및 완료 후와 같은 다양한 처리 로직을 구현할 수 있습니다.

#### 단점

- DispatcherServlet을 통해 처리되는 요청에만 적용됩니다.(정적 리소스, 서블릿 API 직접 사용 등에서는 불가능)

## 필터 vs 인터셉터

![alt text](<image/인터셉터와 필터.png>)

필터는 전역적으로 적용되어 필터가 처리해야 하는 요청이 많아지면 성능 저하를 일으킬 수 있습니다. 범위를 좁힐 수 있다면 인터셉터를 사용하는 것이 좋습니다.   
필터와 인터셉터 모두 특정 범위에 대해 전반적으로 사용되므로 로직 최적화와 필요한 기능만 사용하는 것이 좋습니다.

## 인터셉터 vs AOP

공통 관심 사항을 분리하여 관리한다는 점에서 비슷해보이지만 차이점이 있습니다.   

**인터셉터**: Spring MVC의 일부로, HTTP 요청의 사전 및 응답의 사후 처리를 담당합니다.(웹 요청 처리에 국한)   
**AOP**: 애플리케이션의 모든 계층에 걸쳐 사용할 수 있습니다.(HTTP 요청과 응답 뿐만 아니라 비즈니스의 로직에도 사용가능)

### 주의할 점

인터셉터는 디스패처서블릿의 특정 지점에서 동작합니다. 그에 반해 AOP는 타겟 객체에 대한 프록시를 생성하고, 이 프록시를 통해 어드바이스를 적용합니다. AOP는 프록시 기반이기 떄문에 프록시를 생성할 때 추가적인 오버헤드를 발생시킬 수 있습니다.(현대 하드웨어에서 미미할 거 같으나 성능이 매우 중요한 애플리케이션이라면 고려해야 할 수도 있음)

## 결론

필터와 인터셉터는 유사한 작업을 수행할 수 있지만, 그 적용 시점과 범위가 다릅니다. 보안 처리나 요청/응답의 전역적인 수정이 필요한 경우 필터를 사용하는 것이 적합하고, Spring MVC와 통합된 세밀한 제어가 필요한 경우 인터셉터를 사용하는 것이 좋습니다.

## 참조

[Spring MVC의 HandlerInterceptors와 필터 - baeldung](https://www.baeldung.com/spring-mvc-handlerinterceptor-vs-filter)
