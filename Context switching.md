# Context switching

CPU에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것

## 컨텍스트 스위칭에서 말하는 컨텍스트란?

CPU의 상태, 메모리의 상태 등

## 컨텍스트 스위칭이 왜 필요한가?

CPU의 코어는 한정적이지만, 컴퓨터에서 돌아가고 있는 프로세스/스레드는 코어의 개수보다 더 많다.   
컴퓨터에서 돌아가고 있는 프로세스/스레드를 동시에 돌리기 위해서는 CPU 자원을 나누어 최대한 활용해야 한다.   
- 프로세스/스레드를 동시에 실행하기 위해서
- CPU를 최대한 활용하기 위해서

## 컨텍스트 스위칭은 언제 발생하나?

- 주어진 time slice를 다 사용했을 때
- I/O 작업을 할 때
- 다른 리소스를 기다릴 때

## 컨텍스트 스위칭은 누구에 의해 실행되는가?

OS 커널 중 스케쥴러 또는 디스패처에 의해 관리됩니다.

## 컨텍스트 스위칭이 일어나는 과정(스레드 관점)

1. 인터럽트 발생(time slice를 다 사용했을 때는 타이머 인터럽트 발생)
2. 커널 모드로 전환
3. 현재 실행중인 스레드의 상태 저장
4. 다음 태스크 선택
5. 태스트 상태 복원 및 유저 모드로 전환하여 실행 재개

## 프로세스 관점

프로세스는 스레드와 대부분 동일하지만, 중간에 추가 작업이 있습니다.   
각 프로세스는 독립된 가상 주소 공간을 가지고 있기 때문에, 프로세스 컨텍스트 스위칭 시에는 가상 메모리 주소 공간 관련 처리도 수행됩니다.   

### 프로세스 컨텍스트 스위칭 시 추가 작업

- 페이지 테이블 교체
- TLB(Translation Lookaside) 초기화 또는 교체

### 컨텍스트 스위칭이 미치는 간접적인 영향

캐시 오염(cache pollution)이 발생합니다.   
컨텍스트 스위칭 후 캐시를 들여다 보면 이전 프로세스/스레드에서 실행 됐던 정보들이 들어있을 가능성이 높으므로 바뀐 프로세스에게 필요한 정보는 없을 가능성이 큽니다. (프로세스끼리는 메모리를 공유하지 않으므로, 스레드 컨텍스트 스위칭일 경우엔 있을 수도 있음)   

### 캐시 오염 대응 방안

- 캐시 플러싱(cache flushing): 컨텍스트 스위칭이 일어날 때 캐시 내용을 전부 또는 일부 비우는 방식, 지우는 일 또한 오버헤드를 발생시킬 수 있습니다.
- 캐시 파티셔닝(cache partitioning): 캐시를 여러 파티션으로 나누어, 각 프로세스가 자신의 파티션만을 사용하도록 하는 방법, 오염을 방지하지만 캐시 사용의 유연성이 떨어집니다.(리소스 분배와 공정성)
- 캐시 색인화(cache coloring): 메모리 페이지에 '색'을 할당하고, 같은 '색'을 가진 페이지들이 캐시 메모리 내에서 특정 영역에만 매핑되도록 합니다. 컨텍스트 스위칭이 일어날 때 서로 다른 프로세스가 서로의 영역(메모리, 캐시)를 두고 경쟁하는 것을 최소화합니다.(많은 프로세스가 올라오면 결국 경쟁함, 시스템 설계자가 효과적으로 적용해야 함) [캐시 색인화 - 위키피디아](https://en.wikipedia.org/wiki/Cache_coloring)

## 컨텍스트 스위칭 개념을 사용한 예시

### 서버 비동기 I/O

파일 시스템 접근, 네트워크 요청 등의 I/O 작업이 비동기적으로 처리됨으로써, 서버는 블로킹(작업 완료 대기) 없이 다른 요청을 처리할 수 있습니다. 이로 인해 서버의 동시 처리 능력이 향상되어 효율적인 리소스 사용을 가능하게 합니다

#### 주의할 점

- 에러 처리
- 자원 고갈: 비동기 I/O는 효율적인 리소스 사용이 가능하지만, 과도한 비동기 작업은 시스템 리소스를 고갈시킬 수 있습니다. 예를 들어, 동시에 수행되는 대량의 파일 입출력 작업이나 네트워크 요청은 메모리 사용량을 급증시킬 수 있습니다. 필요에 따라 동시에 실행되는 작업의 수를 제한하는 등의 자원 고갈을 예방해야 합니다.
- 테스트와 디버깅의 어려움

## 참조

[컨텍스트 스위칭 뽀개기! - 쉬운 코드](https://www.youtube.com/watch?v=Xh9Nt7y07FE)
