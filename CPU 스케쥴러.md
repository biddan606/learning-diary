# Scheduler

![alt text](<image/스케쥴러 설명.png>)

실행할 수 있는 프로세스들은 `ready queue` 에서 대기합니다. 이 때 `ready queue` 에서 어떤 프로세스를 실행할지 스케쥴러가 결정합니다.   
스케쥴러는 CPU에서 실행할 프로세스를 선택하는 역할을 합니다.

# Dispatcher

![alt text](<image/디스패처 설명.png>)

스케쥴러가 실행할 프로세스를 선택하면, 디스패처가 실행중인 프로세스와 스케쥴러가 선택한 프로세스를 `Context switching` 하는 역할을 수행합니다. `Context switching` 은 CPU을 건드는 굉장히 민감한 작업이므로 커널 모드에서 실시합니다.   
`Context switching` 이 끝나면 유저 모드로 전환해주는 역할까지 디스패처가 수행합니다.   
디스패처와 스케쥴러를 동일하게 보는 운영체제들도 존재합니다. 역할상 분리되어 있지만, 구현에 따라 다릅니다.

# Nonpreemtive Scheduling

프로세스가 자발적으로 `running` 상태에서 빠져나가는 스케쥴링 방식입니다. 운영체제가 강제로 다른 상태로 전이시키지 않습니다.

## 특징

- 신사적: 운영체제가 프로세스를 끝까지 기다려주기 때문에
- 협력적(coorperative): 프로세스가 스스로 양보하기 때문에
- 느린 응답성: 프로세스가 모든 작업을 수행하고 넘겨주게 된다면 사용자 입장에서는 느린 응답을 받게 됩니다.

# Preemtive Scheduling

운영체제가 개입을 해서 여러 알고리즘에 따라 스케쥴링을 관리 감독하는 방식입니다. 알고리즘에 따라 실행 중인 프로세스를 강제로 다른 상태로 변경하고 다음 프로세스를 실행시킬 수 있습니다. 

## 특징

- 적극적, 강제적: 운영체제가 강제적으로 개입합니다.
- 빠른 응답성: 알고리즘에 따라 더 자주 실행될 수 있도록 하여 사용자 입장에서 빠른 응답을 받을 수 있습니다.
- 데이터 일관성 문제: 프로세스가 작업을 끝내고 상태가 변경되는 것이 아니라 운영체제가 변경하므로 데이터의 일관성이 문제 생길 수 있습니다. `critical session`, `lock` 등으로 해결할 수 있습니다.

# 스케줄링 알고리즘

## FCFS(First Come, First served)

먼저 도착한 순서대로 처리합니다.

## SJF(Shortest Job First)

CPU burst가 가장 짧은 작업의 프로세스부터 실행합니다.

## SRTF(Shortest Remaning Time First)

남은 CPU burst가 가장 짧은 작업부터 프로세스가 실행합니다.

### CPU burst을 어떻게 예측할까?

- 과거 데이터 사용: 이전 실행에서 CPU 버스트 시간을 추적하여 이를 기반으로 미래의 버스트 시간을 예측합니다.
- 휴리스틱(Heuristic) 방법: 특정 애플리케이션이나 작업의 특성을 고려하여 휴리스틱 또는 경험적 방법을 통해 추정합니다.
- 지수 평균(Exponential Averaging): 최근 CPU 버스트 시간을 중요하게 여기면서 과거의 버스트 시간을 포함하여 평균을 내는 방식입니다.
- 운영체제의 도움을 받음: 운영체제의 다양한 통계 및 모니터링 도구를 이용하여 분석합니다.

## Priority

우선 순위가 높은 프로세스부터 실행합니다.

## RR(Round Robin)

time slice(일정 시간)로 나누어진 CPU Time을 번갈아가며 실행합니다.

# 단기, 중기, 장기 스케쥴러

## 장기 스케쥴러(Long-term Scheduler) 또는 작업 스케쥴러(Job Scheduler)

### 역할

디스크에서 시스템의 메모리로 프로세스를 언제 로드할지 결정합니다. 

### 목적

다중 프로그래밍의 정도를 조절할 수 있습니다. 

### 특징

느린 주기로 실행됩니다. 모든 프로세스가 메모리에 올라갈 필요가 없기 때문에, 리소스 사용을 조절하는 데 중요한 역할을 합니다.

## 중기 스케쥴러(Medium-term Scheduler) 또는 스와핑 스케쥴러(Swapping Scheduler)

### 역할

프로세스를 메모리와 스왑 영역(디스크) 사이에서 이동시키는 스와핑을 담당합니다.

### 목적

특정 시점에서 실행되어야 할 프로세스의 수를 조절합니다.

### 특징

프로세스의 상태를 실행 대기 상태 -> 대기 상태로 변경하거나 그 반대로 변경함으로써, 메모리를 효율적으로 관리할 수 있게 해줍니다.

## 단기 스케쥴러(Short-term Scheduler) 또는 CPU 스케쥴러

### 역할

어느 프로세스가 다음 CPU를 사용할지 결정합니다.

### 목적

응답시간, 처리량, CPU 사용량을 최적화하는 역할을 합니다. 준비 상태에 있는 프로세스 중에서 다음에 실행될 프로세스를 선택합니다.

### 특징

모든 스케쥴러 중 가장 빈번하게 실행됩니다.

# 스케쥴링과 비슷한 방식으로 돌아가는 예시

## 작업 스케쥴러(Job Scheduler) 예시

AWS의 오토 스케일링(auto scaling)을 예로 들 수 있습니다. 오토 스케일링은 애플리케이션 트래픽이 증가할 것으로 예상 될 때 사전에 정의된 스케일링 정책에 따라 자동적으로 추가 자원을 배포합니다. 이는 작업 스케쥴러가 사전에 계획하고 준비하는 것과 같습니다.

## 스와핑 스케쥴러(Swapping Scheduler) 예시

컨테이너 오케스트레이션 시스템에서의 리소스 관리를 예시로 들 수 있습니다. 쿠버네티스와 같은 컨테이너 오케스트레이션 시스템은 실행 중인 컨테이너의 리소스 사용량을 모니터링하고, 필요에 따라 컨테이너를 다른 노드로 이동시키거나 리소스 할당량을 조절합니다. 이는 시스템 전체 부하를 조절하고 메모리 사용량을 최적화하는 스와핑 스케쥴러와 닮아있습니다.

## CPU 스케쥴러 예시

메시지 큐를 사용한 작업 처리를 예시로 들 수 있습니다. 메시지 큐는 들어온 작업을 순차적으로 큐에 넣고, 이를 받는 시스템은 작업 방식에 따라 작업을 결정하여 실행합니다. 이와 같은 방식이 준비 상태에 있는 프로세스 중에서 어느 것을 다음에 실행할지 결정하는 CPU 스케쥴러와 닮아있습니다.

## 참조

[CPU 스케줄러는 프로세스를 어떻게 스케줄링 하는 걸까요? - 쉬운 코드](https://www.youtube.com/watch?v=LgEY4ghpTJI&t=775s)
